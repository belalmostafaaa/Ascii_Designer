#!/usr/bin/env python3
"""
ASCII Banner Tool (pyfiglet-based)

Features:
 - Font selection (via --font)
 - Text alignment (left/center/right)
 - Optional colorized output
 - Export feature (Python code, raw text, or JSON)
"""

import argparse
import json
import pyfiglet
import sys

COLORS = {
    "red": "\033[91m",
    "green": "\033[92m",
    "yellow": "\033[93m",
    "blue": "\033[94m",
    "magenta": "\033[95m",
    "cyan": "\033[96m",
    "white": "\033[97m",
    "reset": "\033[0m"
}

# list of fonts
AVAILABLE_FONTS = [
    "slant",
    "big",
    "block",
    "banner3-D",
    "cyberlarge",
    "standard",
    "doom",
    "isometric1",
    "larry3d",
    "starwars"
]


def render_text_raw(text: str, font: str) -> str:
    """Return raw ASCII art (no color) generated by pyfiglet for given font."""
    fig = pyfiglet.Figlet(font=font)
    return fig.renderText(text)


def align_text(ascii_text: str, align: str) -> str:
    """Align multi-line ascii_text to left/center/right."""
    if not ascii_text:
        return ascii_text
    lines = ascii_text.splitlines()
    if align == "left":
        return "\n".join(lines)
    maxw = max(len(l) for l in lines)
    if align == "center":
        return "\n".join(line.center(maxw) for line in lines)
    if align == "right":
        return "\n".join(line.rjust(maxw) for line in lines)
    return "\n".join(lines)


def colorize(ascii_text: str, color: str) -> str:
    """Wrap ascii_text with ANSI color if color is valid."""
    if not color:
        return ascii_text
    code = COLORS.get(color)
    if not code:
        return ascii_text
    return f"{code}{ascii_text}{COLORS['reset']}"


def export_banner(ascii_text: str, export_format: str = "python",
                  var_name: str = "BANNER", embed_color: bool = False,
                  color_name: str = None, output_file: str = None):
    """
    Produce export content in requested format.
    - python: produces a Python file with a variable assigned to a triple-quoted string.
    - raw: outputs plain text banner (with ANSI color codes if enabled).
    - json: produces a JSON object with "text_lines": [...], optionally including "color".
    """

    if export_format not in ("python", "raw", "json"):
        raise ValueError("Unsupported export format")

    lines = ascii_text.splitlines()

    if export_format == "python":
        banner_text = "\n".join(lines)
        if embed_color and color_name:
            color_code = COLORS.get(color_name, "")
            reset = COLORS.get("reset", "")
            banner_text = f"{color_code}{banner_text}{reset}"
        content = (
            f"# Generated ASCII banner (variable: {var_name})\n"
            f"{var_name} = '''\\\n{banner_text}\n'''\n\n"
            f"# Example: print({var_name})\n"
        )

    elif export_format == "raw":
        raw_text = "\n".join(lines)
        if embed_color and color_name:
            color_code = COLORS.get(color_name, "")
            reset = COLORS.get("reset", "")
            raw_text = f"{color_code}{raw_text}{reset}"
        content = raw_text

    else:  # json
        payload = {"text_lines": lines}
        if embed_color and color_name:
            payload["color"] = color_name
        content = json.dumps(payload, indent=2)

    if output_file:
        try:
            with open(output_file, "w", encoding="utf-8") as f:
                f.write(content)
            print(f"[+] Exported banner to: {output_file}")
        except Exception as e:
            print(f"[!] Failed to write file {output_file}: {e}", file=sys.stderr)
    else:
        print(content)


def main():
    parser = argparse.ArgumentParser(
        description="ASCII Banner Tool (pyfiglet-powered, like Sublist3r/Gobuster)"
    )
    parser.add_argument("text", help="Text to render in ASCII")

    parser.add_argument(
        "--font", "-f",
        choices=AVAILABLE_FONTS,
        default="slant",
        help=f"Font style. Available fonts: {', '.join(AVAILABLE_FONTS)} (default: slant)"
    )

    parser.add_argument(
        "--align", "-a",
        choices=["left", "center", "right"],
        default="left",
        help="Text alignment (default: left)"
    )

    parser.add_argument(
        "--color", "-c",
        choices=list(COLORS.keys())[:-1],  # exclude reset
        help=f"Color output (available: {', '.join(list(COLORS.keys())[:-1])})"
    )

    # export feature options
    parser.add_argument(
        "--export-code",
        action="store_true",
        help="Export the generated banner as code (prints to stdout unless --output specified)"
    )
    parser.add_argument(
        "--export-format",
        choices=["python", "raw", "json"],
        default="python",
        help="Format used when exporting the banner (python/raw/json). Default: python"
    )
    parser.add_argument(
        "--export-var",
        default="BANNER",
        help="(python export only) variable name to use in generated Python code. Default: BANNER"
    )
    parser.add_argument(
        "--embed-color",
        action="store_true",
        help="If exporting, embed the ANSI color codes inside the exported content (requires --color to be set)"
    )
    parser.add_argument(
        "--output", "-o",
        help="Write the exported content to this file instead of printing to stdout"
    )

    args = parser.parse_args()

    try:
        ascii_raw = render_text_raw(args.text, args.font)
    except Exception as e:
        print(f"[!] Error rendering text with font '{args.font}': {e}", file=sys.stderr)
        sys.exit(2)

    ascii_aligned = align_text(ascii_raw, args.align)

    if args.export_code:
        color_for_embed = args.color if args.embed_color and args.color else None
        export_banner(
            ascii_aligned,
            export_format=args.export_format,
            var_name=args.export_var,
            embed_color=args.embed_color,
            color_name=color_for_embed,
            output_file=args.output
        )
    else:
        if args.color:
            print(colorize(ascii_aligned, args.color))
        else:
            print(ascii_aligned)


if __name__ == "__main__":
    main()
